---
title: 计算机基本科学
date: 2019-12-11 22:37:26
author: shepherd
img: 
top: false
cover: false
coverImg: 
password:
toc: true
mathjax: false
summary: 
categories: 
  - 计算机内部
tags:
  - CPU
  - 汇编
  - ALU
---

## 计算机发展历史

1.  为了减少人类工作量，出现算盘
2.  然后有了`步进计算器`（原理就是数个齿轮，每个有十个齿，表示0-9，每加到9时，再加1会到0，前面的齿轮+1，就像算盘，减法相反，乘除不过是多个加减），可以做加减乘除
3.  `computer`最开始是指计算的人，后来才指机器
4.  因为计算机可以减少很多人力物力，然后计算机高速发展

## 电子计算机

### **机电**

1. 早期使用机械继电器连接电路， 比如控制马达，使齿轮+1（每秒50次）
2. 缺点：因为是机械，所以有延迟，磨损。
3. 要排除故障太费力，还会吸引臭虫（`bug`）

### **热电子管（玻璃）**

1.  二极管（`单向流动`）： 一极加热放出电子，另一极吸引正电子（`电流`）；
2.  三极管：在二极管的基础上加一个控制电极，施加正电允许电子流动，负电阻止电子流动（与继电器功能一样，断开和闭合电路，但没有磨损） 。
3.  缺点：成本高， 会向灯泡一样被烧坏；

### **晶体管（固态）**

{% qnimg 晶体管.png %}

1. 中间是半导体，可以控制半导体的导电性来控制电流。
2. 每秒10000次；
3. 体积更小，因为是固体，所以相对于热电子管更经用；（现在晶体管的小于50nm，而一张纸的厚度是10,000nm，每秒几百万次，工作时间更耐久）
4. 后来采用二进制进行计算

## 布尔逻辑和逻辑门

1. 使用两种状态就可以表示所有东西了。 
2. 晶体管不仅可以开和关， 还可以让不同大小的电流通过，早期的计算机有三进制和五进制，但是进制越多越难区分信号（`被干扰`）
3. 早期数学已经开始研究二进制了，已经解决了所有运算法则（`布尔代数`）

**三个基本布尔操作** 

`NOT`：将布尔值反转

{% qnimg NOT.png %}

`AND`：有false则output为false（将晶体管串联实现）

{% qnimg and.png %}

`OR`：有ture则为true

{% qnimg OR.png %}

`XOR`：相同则为false；不同为true

{% qnimg xor.png %}

## 寄存器和内存

因为使用ALU计算后的数值需要存起来，于是有了内存。

**RAM**（`Random Access Memory`随机存取存储器）：

- 只在通电时数据是保留的 

### **锁存器**

- 可以记录一位信息

 {% qnimg AND-OR-latch.png %} 

 {% qnimg 门锁.png %} 

### **寄存器**

- 并排存放的一组锁存器

- 寄存器能存一个数字，这个数字有多少位叫`位宽`

  {% qnimg 8位寄存器.png %} 

- **Memory**
  
  - 因为要存更多数据，并排存放的话需要很多数据线，此时需要用矩阵

 {% qnimg 矩阵1.png %} 

 {% qnimg 矩阵2.png %} 

- 那如何确定一个地址呢：

  - 使用“多路复用器（`Multplexers`）”

  - 原理（将行和列转化位8位二进制）

     {% qnimg 多路复用器.png %} 

抽象化

**256-bit-memory**

 {% qnimg  256-bit-memory.png %} 

**256-byte-memory**

 {% qnimg  256-byte-memory.png %} 

可以将上面整体看成一个可寻址内存（RAM）：

 {% qnimg  addressable.png %} 

以上内存是一个静态内存`SRAM`,现在有`DRAM`等很多

## ALU

在CPU里面，ALU主要负责计算和判断

### 算术单元（arithmetic）

负责加减

- **半加器**（`Half adder`）
  - 功能：输入两个bit，输出两个的**和（`SUM`）**及**进位（`CARRY`）**
  - 实现：

{% qnimg 半加器.png %}

- **全加器**（`Full adder`）
  - 功能：三个输入bit，同样输出`sum`与`carry`
  - 实现电路：

{% qnimg Fulladder.png %}

例子（8位行波进位加法器）

{% qnimg 8bitadder.png %}

超出所表示位数表示“溢出”，后果很严重。

ps：现在使用**超前进位加法器**

### 逻辑单元（logic） 

- 用来执行一些逻辑操作，比如AND OR NOT等，还有判断是否为负数，是否为0等

  {% qnimg 判断是否为0.png %}

抽象化：

{% qnimg alu.png %}



## 自建CPU

### 组件

- 需要RAM

- *假设*一个操作码（`opcode`）

  前四位：
  
  {% qnimg opcode.png %}

​	后四位表示`地址`

- 所需寄存器
  - **指令地址寄存器**：追踪程序运行到哪里，存当前指令的内存地址
  - **指令寄存器**：存当前指令
- 启动计算机时，寄存器从**0**开始

### CPU工作阶段

#### FETCH PHASE

- 取指令阶段

- 将指令地址寄存器连接到`RAM`，寄存器的值为0，RAM返回地址0的值
- 将值给*指令寄存器*

#### DECODE PHASE

- 解码阶段

{% qnimg 解码.png %}

- 识别操作码电路

  {% qnimg 识别操作码.png %}

#### EXECUTE PHASE

- 执行阶段

{% qnimg 执行阶段.png %}

- 操作码正确可以打开RAM的**允许读取线**
- 这里说的是将地址14的数据放入寄存器A（`RAM需要连接所有寄存器`）
- 这个阶段完成，指令地址寄存器+1

注：以上图片均来自 Youtube [Crash Course]( https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulI )
