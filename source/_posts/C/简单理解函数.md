---
title: 简单理解函数
date: 2019-11-5 22:37:26
author: shepherd
toc: ture
categories: [C,函数]
---

> c对类型的检查并不严谨
> emmm形参实参我哭了。。。tm直接叫参数不好吗

> 没指针的函数只有参数值的传递，不能改变原有参数的值
>

>  `= `左边是左值，因为是运算
>

> C语言通过调用函数来实现功能

## 分类

### 库函数

由C语言提供，使用时只需要程序前**包含函数的头文件**即可

### 用户定义函数

用户自己定义函数，要在函数中定义函数本身， 在主函数调用中还必须对被调函数进行类型说明，才能使用.

#### 有返回值的函数

此类函数调用后向调用者返回一个执行结果，必须定义类型.

#### 无返回值函数

并非真的没有，只是只关心处理过程而已，无返回值时可定义返回类型为空(`void`)，或者不写

#### 无参函数

函数定义、说明、调用均不带参数，主调函数和被调函数之间不进行函数传送，一般这类函数用于完成指定功能，可以返回（`return`）或者不返回函数值.

#### 有参函数

函数定义和说明中有参数.

说明:

- 规定了传输数据的类型和数量
- 定义时不给他分配空，只有在使用时才临时给他分配，结束即释放
- 参数可以是变量，表达式，常量，函数等，在使用时必须有确定的值
- 与使用的参数在数量，类型，顺序上必须保持一致

#### 返回指针的函数

- 返回本地变量的地址是危险的

- 返回全局变量和静态变量的地址是安全的(虽然安全，但不推荐使用，或者尽量避免使用来传递参数)
- 返回在函数内的`malloc`是安全的，但容易造成问题
- 最好的做法就是返回传入的指针

> 使用全局变量和静态本地变量的函数是线程不安全的

### 函数注意事项

c语言中所有函数都是平行的，即在一个函数体内不能定义另一个函数

但允许函数之间相互调用，嵌套调用

但`main`不允许被其他函数地调用，且c语言只允许有一个`main`

## 函数的定义

`函数类型 函数名(参数及其类型)`
`{`
       `函数变量说明;`
       `语句;`
`}`

⑴不关心类型可定义为`void`

⑵命名要满足标识符

⑶定义时参数必须有类型，看情况要不要参数

⑷可以没有参数，但括号不能省（与变量区分）

## 函数声明

- 旧标准放在主函数里面，新标准可以放在主函数外面

`函数类型 函数名([参数表]);`

说明:

①声明时，可以不写参数，但类型必须写.

②`#include`也是调用函数，使用`<>`时，指定系统会首先查找C编译的头文件路径，使用`""`时，会首先查找当前目录.

③定义是创造，声明是引用.

④`int`型和`char`在定义时可不写类型，系统默认`int`型

⑤当定义在主调函数前面时可不声明，当返回值为`int`和`char`时，也可不声明

- 函数调用一般形式：

`函数名(参数表)`

- 无参函数没有参数表各参之间用逗号隔开

- 引用的参数和定义的参数必须一一匹配

- 允许自己调用自己，叫**递归调用**.

- 函数调用只能返回值

## 变量类型和作用域

`printf("%s",_func_);`可以得到所在函数名

### 局部变量

- 也叫内部变量，只作用与内部，也就是定义的地方内，在复合语句定义的变量，只在他的范围内有效.

1. 参也属于局部变量
2. 不同的函数可以使用相同的变量，他们互不干扰
3. 只有被调用时才会被分配储存单元，用完就释放

### 全局变量

- 也叫外部变量，在函数外部定义的变量，作用于整个源程序，但只有经过声明(`extern`)才能使用，在函数之前定义的变量可以不用声明.

1. 有效范围从定义位置到文件结束
2. 若全局变量和局部变量同名，在局部变量的作用域里，全局变量失效.
3. 定义在外部，与任何函数无关
4. 任何函数都可以使用它

### 初始化

- 全局变量默认是0
- 指针默认`NULL`
- 只能用编译时刻已知的值来初始化全局变量
- 初始化发生在`main`之前

## 变量的储存方式

- 全局和局部是由变量的定义域来划分的

- 若从变量存在的时间长短来划分，可分为动态储存变量和静态储存变量，也就是说，变量的生存期取

  于变量的储存方式.

### 动态

#### `auto`自动变量 

❶未加储存类型说明的默认`auto`

❷属于局部变量，作用域仅限于变量个体内(因此不同函数使用相同的变量不会混淆)

❸属于动态储存方式，只有被调用时才会被分配储存单元，调用结束即释放，结束后，自动变量的值不会被保留.

❹默认数据不定

#### `register`寄存器变量

❶采用寄存器型存储(存在`CPU`的寄存器内)的变量，叫寄存器变量，可以提高访问效率

❷其他类变量都是放在内存储器内，需要反复访问内存储器，效率不高

### 静态

#### `extern` 外部变量

❶也叫全局变量

❷定义，在声明之后编译系统不会为他分配内存空间

#### `static`静态变量

❶相对于自动变量的生存期，静态局部变量始终存在，生存期为整个源程序.

❷作用域和自动变量一样，退出后，尽管变量依旧存在，但不能使用他，再次调用可继续使用，而且保留了上次使用后的值

❸默认0

#### 静态全局变量

- 只在这个`.c`文件里有效

- 即在外部变量前加`static`，区别就是静态的限制了作用域，静态的在各个源文件都是有效的，静态只在定义的源
- 文件内有效，可以避免在其他源文件中引起错误.
- 因此，变量说明的完整形式为

`储存类型说明符 数据类型说明符 变量名;`

特殊的地方就是有着全局的生存期，是函数内部的作用域

本地变量的一些规则：

- 是定义在块内的（一对大括号）
- 函数进入块之前，其中的变量不存在，离开后消失
- 块里的函数名与外面的变量同名会掩盖外面的

> 静态变量其实就是特殊的全局变量
>
> -  他们位于相同的内存区域 
> - 特殊的地方就是有着全局的生存期，是函数内部的作用域

```c
#include <stdio.h>

int c;

int main(int argc, char const *argv[])
{
	int a=0;
	static int b=0;
    printf("&c=%p\n", &c);
    printf("&a=%p\n", &a);
    printf("&b=%p\n", &b);

    return 0;
}
```
可以看到全局变量和静态变量的地址差`4(int)`

## main里面的参数

```c
int main(int argc, char const *argv[]){
}
```

这些参数值是从操作系统的命令行中得到

`argc` 整数

`argv`  字符串 

`argv[0]`是你执行的名字

`argv[1]`是你后面输入的指令

可以用来搞快捷方式