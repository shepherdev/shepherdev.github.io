---
title: C Array
date: 2019-11-2 22:37:26
author: shepherd
img: 
top: false
cover: false
coverImg: 
password:
toc: ture
mathjax: false
summary: 
categories: 
  - 编程
tags:
  - Array
  - C
---

## 一维数组

数组长度可以这样表示：` sizeof(a) / sizeof(a[0]) `**<u>在数组作为函数参数时不行</u>**

因为在函数参数表内：`sizeof(a) == sizeof(type* )`

### 使用数组的原因

为了方便处理更多的数据

### 定义格式

`类型    数组名[元数个数]`
1.名字遵循规范

2.元数个数一般是常量 (整数)，不能是变量 //二级考试，实际上c99，c11已经支持变量  

3.**内存大小=元素类型*元素个数**

4.一旦定义，不能改变

### 数组的初始化

1.`数组类型  名称[n]={0,....n-1};`

2.给特定元素赋值,其他默认是`0`，如果两个特定元素中间有元素，必须把`0`补上

3.`数组类型  名称[ ]={0,....n};`

不写个数,由写的元素来定个数;
4.

```c
int  a[10] = {
    [0] = 2, [3] = 3, 4,  //表示[4] = 4
};
//c99才有用
```

### 注意事项

`数组名[下标]`

- 数组变量本身不能被赋值
- 要把数组所有元素交给另一个数组，**必须采用遍历**（区分结构体）

- 下标为整型常量或整型表达式

- 只能逐个引用数组（**遍历**）

- 编译器和运行环境都不会检查越界问题，虽然有时候也不会出错
  - `windows`会提示`segmentation fault`
  - 特例:定义`a[0]`存在，但无用

- 特点:个数是`n`，实际上是`0,1,2,.....n-1`
  - 与储存格式与c语言有关，储存时会有一个首地址，第一个数据会直接存到首地址中，第二个数据存到`首地址+类型字节*i`中i本该是2，在C语言中是1，不然会增加运算量，但其他语言可以

## 二维数组

### 定义格式

`类型  数组名[常量表达式1][常量表达式2]`

- 说明：表达式1表示行，2表示列

- 存放顺序：按行从左到右依次

### 引用格式

`数组名[下标][下标]`

- 下标可以是常量或者整型表达式

### 初始化格式

#### 1.分段赋值

```c
int score[5][3] = {
  {1, 2, 3},
  {4, 5, 6,},...
}
```

#### 2.连续赋值

```c
int score[5][3]={1,2,3,4,5,6...}
```

#### 3.给部分元素赋值

- 其他自动取0

- 或者全部赋值，但一维的长度不给出

如

```c
int score[][3]={1,2,3,4,5,6,7,8}
```

## 遍历数组

```c
#include <stdio.h>

int main ()
{
    char a[] = {0,1,3,4,5,6,7,8,9,-1};
    char *pa = &a[0];
    int i;
    //1.普通方法
    for ( i=0; i<sizeof(a)/sizeof(a[0]); i++)
    {
        printf("%d\t", a[i]);
    }
    printf("\n");
    //2.在数组后面添加一个-1，利用指针输出，结束
    while ( *pa != -1)
    {
        printf("%d\t", *pa++);
    }
    printf("\n");
    return 0;
}
```

## 字符串数组

**使用时注意初始化！**

```c
char *a[]={NULL};
char *a[]={0};
```

### 指向字符串的指针变量

- c语言中对字符常量的处理是按照**字符数组**来处理的

```c
char  *cp;
cp="love"; //初始化
printf("储存的内容:%s\n", cp );
```

说明：

- 实际上字符串的第一个元素的地址赋给`cp`
- 系统先输出首字符，然后指针自动`+1`，继续输出，直到碰到`\0 `

- 因为c语言中没有字符变量，所以存放字符串用**字符数组**

### 格式

``` c
char name[];
```

- 初始化同一维数组

如：

```c
char i[] = {'a','n','d'}//此时数组长度为3
```

- c语言允许用字符串的形式给数组赋值；此时c语言默认字符串以`\0`结尾，会用一个字节来存放`\0`

如：

``` c
char i[] = "china";//注意此时数组长度为6
```

- 输出格式：

  ```c
  printf("%s", i);
  ```

定义为字符类型时`scanf`输入的字符中不能带空格，空格后面的东西不会被赋值。

并且，由于指针的原因，输入格式为：

```c
scanf("%s",name);//不需要&
```

- 字符串输出(在`stdio.h`里)：`puts(name);`

- 输入：`gets(name);`
  - 有点小问题，需要和`getchar()`搭配使用
  - 空格不会使输入结束，只有回车可以
  

### 注意事项

#### 字符串常量

```c
char* s = "Hello, world!";
```

- s是一个指针，初始化为指向一个字符串常量
  - 由于这个常量所在的地方，实际上`s`是`const char* s`，但由于历史的原因，编译器接受不带const的写法
  - 但是师徒对s所指的字符串做写入会导致严重的后果
- 如果需要修改字符串，应该用数组：

```c
char s[] = "hello world";
```

#### 常见错误

```c
char *string;
scanf("%s", string);
```

- 以为`char*`是字符串类型，定义了一个字符串类型的变量`string`就可以直接使用了
  - 由于没有对`string`初始化为0，所以不一定每次运行都出错

#### 指针还是数组？

```c
char *str = "hello";
char word[] = "hello";
```

- 数组：这个字符串在这里
  - 作为本地变量空间自动被回收
- 指针：这个字符串不知道在哪里
  - 用来处理参数
  - 动态分配空间
- 要构造一个字符串用数组，处理用指针

#### char*是字符串？

- 字符串可以表达为`char*`的形式
- `char*`不一定是字符串
  - 本意是指向字符的指针，可能指向的是字符的数组（`int*`）
  - 只有它所指的字符数组有结尾的0，才能说它所指的是字符串

- 字符串的赋值实际上是把指针指向了那个值，并没有创造新的值

  ```c
  char a[10] = "";//表示一个空的字符串，a[0]="\0"
  char a[] = "";//这个数组的长度只有1
  ```

### 总结

`char  a[][10 ];!=char  *a[];`

`char (*a)[10];`

#### 初始指针字符数组的方法

`char *a[]={NULL};`

`char *a[]={0};`

```c
char *a[ ] = {
"January",
"February",
"March",
"April",
"May",
"June",
"july",
"August",
"September",
"October",
"November",
"December",
};
```

`a[]`存了每个字符常量的首地址

