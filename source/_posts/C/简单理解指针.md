---
title: 简单理解指针
date: 2019-11-3 22:37:26
author: shepherd
toc: ture
categories: [C]
---

`*`与`&`相互作用：`*&a`实际上就是`a`变量

- 是C语言的优势，指针也就是地址

<!-- more -->

### 定义格式

`类型 *指针变量名;`或`类型* 指针变量名;`

说明

- 指针变量的类型是他指向内存单元中存放的**数据类型**
- 指针变量必须被赋值语句**赋值初始化**后才能使用，否则，严重的话会死机
- 可初始化为`0`，`NULL`(不指向任何值)或者某个地址
- 指针变量**只能接受地址**,赋以数据会错误

### 引用

- 在指针引用前，要定义，赋值，否则，会造成系统混乱


### 指针运算符

#### 取址符&

- 单目运算符,结合性自左向右.

#### 取内容符*

- 也叫间接引用运算符,结合性自左向右,且*后面只能是指针.
- 指针的值也可以改变,也就是改变指向.

### 指针的类型

- 不同类型的指针不能相互赋值（虽然没问题）

```c
int* a = NULL；
char* b = NULL；
a = b；
```


如果`*a=0`，则`*b[0]-*b[3]`都会变成0

- 指针类型的转换
  - `void*` 表示不知道指向什么东西的指针：

  - `int *p = &i; void*q = (void*)p;`
    - 并没有改变`p`所指的变量类型，而是用不同的眼光通过`p`去看它所指的变量
      - `q`此时认为p指向的变量不是`int`，而是`void`

### 场景1

利用函数交换数值（也就是说传给主函数多个数值）

```c
#include <stdio.h>

void swap(int *pa, int *);

int main() {
    int a, b;
    a = 1;
    b = 2;
    swap(&a, &b);
    printf("a=%d, b=%d", a, b);
    return 0;
}

void swap(int *pa, int *pb){
    int t;
    printf("pa=%p,pb=%p\n", pa, pb);
    printf("*pa=%d,*pb=%d\n", *pa, *pb);
    t = *pa;
    *pa = *pb;
    *pb = t;
    printf("pa=%p,pb=%p\n", pa, pb);
    printf("*pa=%d,*pb=%d\n", *pa, *pb);
}
```

### 场景2

1.函数返回运算状态，指针返回结果

2.当要返回的值多个都是有效的结果时，要分开返回了

### *p和p

- `*p`是常量，`p`是变量

## 指针与数组

**注意：**函数**参数表的数组**其实就是**指针**

- 以下四种函数原型是等价的
  - `int sum(int *a, int b)`
  - `int sum(int*, int)`
  - `int sum(int a[], int b)`
  - `int sum(int [], int)`

> **数组就是特殊的指针**

- `[]`对指针和数组都可以用，同理`*`也一样

> 因为`int a[]<==>int *const a= ` 
>
> 所以这里不能被赋值
>
> 如`a = b;//error`

### 一维数组指针

```c
int a[10];
int *p;
*p = &a[0]
```

> 在C语言中规定**数组名**代表数组中的**首地址**(声明函数的参数不是,他不占实际内存单元)

实际上`p=&a[0]`与`p=a`一样

- 但是数组的**单元**表达的是**变量**，需要`&`取地址
  - 意思是把数组的**首地址**赋给p

`p+1`实际是`p+1*d`，`d`代表**字节数**

综上，引用数组元素的方法有

- **下标**法:`a[0]或p[0];`
- **指针**法:`*(a+i)`或者`*(p+i);`

> a是数组的首地址，即指针常量

- 因为数组元素也是内存变量，所以**此类指针的定义和使用**和**指向变量的指针变量**相同.

```c
int a[10] *p;
p = a;
```

- 此时`p`指向`a[0]`，下面可以用`p`表示数组元素.
  - 下标表示:

```c
p[0],p[1],...//需要定义指针数组
```

- 指针表示法:

```c
*(p+0),...
```

- 注意：使用指针变量引用数据时，必须关注当前值
  - 比如：若`p=p+3`，则`p[0]`代表`a[4]`

### 二维数组指针

```c
int  a[3][4];
```

- `a`是首地址

- 三个行元素的地址分别是:`a,a+1,a+2`且`a[0],a[1],a[2]`也是地址量，即`*(a+0),*(a+1),*(a+2)`是一维数组的首个元素的地址

每个元素的地址`&a[i][j],a[i]+j,*(a+i)+j`都可以表示

元素的表示`a[i][j],*(a[i]+j),*(*(a+i)+j)`可以表示

> 要使用这两种方法引用元素的前提是二维数组全赋给指针数组
>
> ```c
> int  (*p)[3], a[2][3];
> p = a;
> ```
>
> **注意:**`()`不能去掉，因为`[ ]`的优先级高于`()`
>
> - 意思是一个指向二维数组的指针，**只占int的字节数**
>
> `type *p[num`]的意思是一组指针，每个元素保存一个指针

- 等价关系
  - `a+i == p+i`
  - `a[i] == p[i] == *(a+i) == *(p+i)`
  - `a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)`

说明:

- ​    赋给指针时首地址是`a[0]`，`**a`表示`a[0][0]`

## 初始化的方法

方法一

```c
char a[ ] = {0,1,3,4,5,6,7,8,9,-1};
char *pa = &a[0];
```

方法二

```c
char a[ ] = {0,1,3,4,5,6,7,8,9,-1};
char *pa;
pa = &a[0];
```

错误表达

```c
char a[ ] = {0,1,3,4,5,6,7,8,9,-1};
char *pa;
*pa = &a[0];//Error!
```

## 算术操作及比较

- 只可以作加减法
  - `p+n`指的是`p`指向的数据单元之后的第`n`个数据单元

    - `int  *p;`(设`p`的初始值是`2000`)

      `p+1;`表示`2002`

- 指针值的比较（`<,<=,>,>=,==,!=`）

  - 前提条件：`p1`和`p2`是同一类型的指针变量，并且都指向同一段连续的储存空间

  - 则`p1<p2`为真的话结果是1，否则是0

- 数组是递增排列的，`a[0]>a[1]`

## CONST

1.**只有C99**以后的支持

```c
int * const q = &a;
```

- 此时`q`被**固定**，`q++`不能实现；

```c
const int *q = &a;
int const* q = &a；
```

- `q`可以被赋地址，但`*q`不能被赋值

2.非`const`转换为`const`

```c
针void f(const int* x);
int a = 15;
f(&a);  //ok
const int b = a;
f(&b);  //ok
b = a + 1;  //error
```

- 适用于传递的参数类型比地址大时

3.`const`数组

```c
const int a[] = {1,2,3};
```

此时每个单元都是`const`，

只能通过初始化赋值，

因为把数组传入函数时是地址，所以函数可以修改数组的值

> 为了保护数组不被破环，可以设置参数为`const`

```c
int sum(const int a[ ] );
```

## 0地址

- 通常`0`地址不能乱碰
- 你的指针不应该有0值

- `0`地址可以来表示特殊的事情
  - 返回的指针是无效的
  - 指针没有真正初始化

- `NULL`是一个预定的符号，表示`0`地址
- 一般用`NULL`表示`0`地址

## 作用

- 传入较大的数据时用作**参数**

- 传入数组后对数组进行**操作**

- 返回多个结果
  - 修改多个变量

- 动态申请内存 