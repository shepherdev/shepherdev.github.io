---
title: 对象
date: 2020-04-18
toc: true
author: shepherd
categories: [前端,JavaScript]
---

## 简介

most things are objects.

<!-- more -->

对象是一个包含相关数据和方法的集合，下面就是一个简单的对象

```js
var person = {
  name : ['Bob', 'Smith'],
  age : 32,
  gender : 'male',
  interests : ['music', 'skiing'],
  bio : function() {
    alert(this.name[0] + ' ' + this.name[1] + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.');
  },
  greeting: function() {
    alert('Hi! I\'m ' + this.name[0] + '.');
  }//注意这里没有逗号
};
```

对象与值之间使用`:`隔开，对象里的string、number、array也叫对象的属性（property），函数也叫对象的方法（method），上面整个对象被称为对象的字面量（literal）

## 访问

### 点表示法

使用`.`来访问对象里的属性方法

```js
person.name;
person.age;
```

对象也可以作为值

```js
name: {
	first:'Bob',
	last:'Smith'
}
//访问
person.name.first;
```

### 括号表示法

```js
person['age'];
person['name'];
```

与数组有点类似，不同的是：对象是字符串到值的映射，数组是数字到值的映射

## 设置值

通过访问的形式修改

```js
person.age = 19;
```

也可以新增一个属性或者函数

```js
person.other = 'other';
person.fun = function(){
    alert('hello world');
}
```

括号表示法的优点就是可以动态的设置成员名字

```js
var dataName = 'height';
var dataValue = '1.60cm';
person[dataName] = dataValue;
```

## this

代表当前对象，当对象实例化时非常有用

## 构造函数与对象

JS不像java那样可以使用class来声明类，而是使用了**构造函数**的特殊函数来定义

```js
//简单定义
function createNewPerson(name) {
  var obj = {};
  obj.name = name;
  obj.greeting = function () {
    alert('Hi! I\'m ' + this.name + '.');
  }
  return obj;
}
//调用
var salva = createNewPerson('salva');
salva.name;
salva.greeting();
```

但这样定义有点不方便，因为创建一个空对象还要返回它，以下是一个便捷方法

```js
//名字注意大写，代表他是一个类（构造函数）
function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}
//调用
var person1 = new Person('Bob');
var person2 = new Person('Sarah');
```

## 创建对象的其他方式

### Object()

```js
var person1 = new Object();/*这是一个空对象*/
var person1 = new Object({
  name : 'Chris',
  age : 38,
  greeting : function() {
    alert('Hi! I\'m ' + this.name + '.');
  }
});/*这是一个有属性方法的对象*/
```

### create()

这个方法可以根据现有对象创建新的对象

```js
var person2 = Object.create(person1);
```

## 原型prototype

JavaScript 常被描述为一种**基于原型的语言 (prototype-based language)**——每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 

准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的`prototype`属性上，而非对象实例本身。

在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。--[MDN](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes)

### 实例

说一下自己的理解，我们在JavaScript创建的函数都有共同的属性叫prototype，它长这样

```js
function test (){}
console.log(test.prototype);

Object 
    constructor: ƒ test()
        arguments: null
        caller: null
        length: 0
        name: "test"
        prototype: {constructor: ƒ}
        __proto__: ƒ ()
        [[FunctionLocation]]: VM123:1
        [[Scopes]]: Scopes[2]
    __proto__:
        constructor: ƒ Object()
        hasOwnProperty: ƒ hasOwnProperty()
        isPrototypeOf: ƒ isPrototypeOf()
        propertyIsEnumerable: ƒ propertyIsEnumerable()
        toLocaleString: ƒ toLocaleString()
        toString: ƒ toString()
        valueOf: ƒ valueOf()
        __defineGetter__: ƒ __defineGetter__()
        __defineSetter__: ƒ __defineSetter__()
        __lookupGetter__: ƒ __lookupGetter__()
        __lookupSetter__: ƒ __lookupSetter__()
        get __proto__: ƒ __proto__()
        set __proto__: ƒ __proto__()
```

向原型中添加属性

```js
test.prototype.foo = 'bar';
```

### 理解原型对象

> 原型链中的方法和属性没有被复制到其他对象
>
> 官方并没有规定方法可以直接访问对象原型，原型链的'连接'被定义在内部属性中，在JavaScript中用`[[prototype]]`表示，在使用chrome和firefox时，提供了`__proto__`这个属性可以访问原型对象

需要注意的是`__proto__`和`prototype`的区别，前者可以访问对象的原型对象，后者包含了一个对象，可以在里面定义被继承的成员，`prototype`是构造器的专属属性

而前面说的`Object.create()`，就是将参数里的对象作为原型对象返回一个新的对象

## constructor

每个实例的对象还会从原型中继承`constructor`属性，该属性就是这个对象的构造函数

```js
let o1 = new test();
//下面两种方法都可以得到构造函数
o1.constructor;
o1.__proto__.constructor;
```

用途1，利用这个构造函数创建对象

```js
let o2 = new o1.constructor();
```

用途2，得到构造函数的各种信息

```js
//名字
o1.constructor.name;
//参数长度
o1.constructor.length;
```

## 修改原型

因为原型链的特性，所以增加构造函数的原型属性时，使用构造函数实例化的对象也可以访问到这个属性，如

```js
Person.prototype.newAtrribute = function(){
	alert('hello'+this.name[0]);
}
person1.newAtrribute();
```

注意上面的this是在函数里面的，在使用时就会转换为对象实例

> 常见的对象定义模式就是，构造器（函数体）里定义属性，prototype属性里定义方法