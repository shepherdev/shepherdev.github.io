---
title: 3.传输层
date: 2020-05-013 12:00
author: shepherd
toc: true
mathJax: true
categories: [计算机网络,Top-Down-Note]
tags: [TCP,UDP]
---

本章详细的介绍了运输层的TCP和UDP协议

## 3.1-概述运输层服务

运输层对不同主机之间的应用程序提供了**逻辑通信（logic communication）**，类似将应用层连在了一起。

运输层协议实在端系统中实现的，运输层通过应用层接收到的报文转换为运输层分组，该分组被称为**报文段（segment）**，然后交给网络层被封装成网络层分组（数据报） 向目的地发送。

### 3.1.1-运输层和网络层的关系

网络层为主机之间提供逻辑通信，运输层为主机的应用程序提供逻辑通信。

### 3.1.2-运输层概述

提供了两个协议：

- UDP（用户数据报协议）：提供不可靠的，无连接的服务
- TCP（传输控制协议）：提供可靠的，面向连接的服务

当我们设计应用程序时，必须选择其中一个协议（才能生成套接字）。

为了理解这两个协议，先说一下网络层的**IP**，IP的服务**是尽力而为交付服务（best-effort delivery service）**，它不保证报文段的交付、顺序交付及完整性，所以被称为**不可靠服务（unreliable service）**，每个主机都有一个IP地址。

而UDP和TCP则是将两个端系统的IP对话服务扩展到进程之间的对话。

## 3.2多路复用和多路分解

 当运输层报文到达运输层时，运输层检查这些字段，得到套接字（唯一标识的），然后将数据传给这个套接字，这些工作被称为**多路分解（demultiplexing）**。

在源主机收集数据块封装首部信息，生成报文段传给网络层，这些工作被称为**多路复用（multipexing）**。

所以多路复用要求：

1. 套接字有唯一标识符
2. 有特殊字段来指示对话的套接字（如源端口和目标端口）

> 注意0-1023端口是比较特殊的，如80给了HTTP，25给了SMTP...详细请看[RFC1700](https://www.rfc-editor.org/rfc/rfc1700.html)

<img src="https://cdn.jsdelivr.net/gh/shepherdev/blog_image/article/2020/transport-layer.png" style="zoom: 33%;" />

### 1.无连接的多路复用和多路分解

使用python创建一个UDP套接字来分析

```python
clientSocket = socket(socket.AF_INET,socket.SOCK_DFRAM)
```

这种方式创建的socket在运输层会自动被分配一个1024-65535的端口，并且该端口未被主机使用，也可以使用bind()方法指定端口

```python
clientSocket.bind(('',9001))
```

如果是设计知名协议（http、smtp）的服务端，那就要使用这个协议指定的端口。

**复用和分解**

假设A主机有一个进程额UDP端口是10000，发送给B主机UDP端口为20000的进程，那么主机A的运输层首先创建一个运输层报文，包括**数据，源端口，目标端口**，传递给网络层，网络层封装到IP数据报中，向B主机发送。

到达B时，B的运输层检查目标端口，然后把数据交给该端口对应的套接字（定向分解）

**注意事项**

UDP套接字是一个二元组，包含了一个IP和端口，比如上面bind方法里面的参数

```python
('',9001)# 第一个参数是IP，当为空时代表本机
```

源端口的作用，是服务端返回数据时用的

### 2.面向连接的复用和分解

TCP套接字使用了四元组(src_IP,src_prot,dst_IP,dst_port)标识，目标主机会使用四个值分解到相应的套接字。

使用python代码演示一下TCP

- TCP客户端创建套接字并连接上服务端

```python
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName,serverPort))
```

- 当服务端接收到请求后，定位服务器进程，然后建立一个新的套接字

```python
connectionSocket, addr = serverSocket.accept()
```

- 此时服务端会注意连接请求报文的4个值，如果后续到达的报文段4个值与连接的4个值相等，则将数据分解到新建立的套接字上。这就算建立连接完成了。
- 前面说的持续HTTP就是使用同一个套接字传输数据，非持续就是不断产生新的套接字，这是比较浪费服务端性能的

> **端口的安全性**
>
> 端口对于破坏者来说相当于突破口，如果该端口上的应用程序有缺陷，则破坏者就能在攻击的主机上执行任意代码，导致主机被攻陷。

## 3.3-UDP

UDP被称为是无连接的，因为发送方与接收方的运输层实体之间没有握手。

DNS通常就使用了UDP，因为TCP需要握手，如果使用TCP的话，DNS查询会慢很多，而UDP不需任何准备就可以传输数据

TCP是可靠的传输协议，那我们什么时候使用UDP呢。下面是比较适合使用UDP的几点

- **希望随时发送数据，可以容忍一点数据丢失**，TCP有一个拥塞控制机制，当链路拥挤时会阻塞运输层的发送
- **不想建立连接**，连接也是有往返时延的，如DNS使用UDP
- **分组首部占用小**，UDP报文端有8字节的首部，TCP有20字节

因为UDP没有拥塞处理，所以会有较高的丢包率

### 3.3.1-UDP报文段结构

应用层数据占用UDP的数据字段。UDP首部有4个字段，每个占两字节；除了源端口和目的端口，还有Length和校验和，Length表示报文段的字节数（首部+数据）

<img src="https://cdn.jsdelivr.net/gh/shepherdev/blog_image/article/2020/udp-segment.png" style="zoom:33%;" />                                                                                                                         

### 3.3.2-UDP校验和

为了确保数据在发送过程中不会出错，发送方的UDP会对报文中的所有16bit字节进行相加（溢出部分不管）再取反，将结果放在校验和字段，接收方将所有16bit全相加，如果结果不是`1111 1111 1111 1111`则代表出了差错

> 更多计算细节参考https://segmentfault.com/a/1190000008543293

其实数据链路层也有差错控制，为什么UDP还需要呢？主要是因为不能保证源和目的之间所有链路都有差错控制，其次就是当报文传递到内存中也可能出现差错。

## 3.4-可靠数据传输原理

